from numpy import sqrt
import matplotlib as mpl
import matplotlib.pyplot as plt
import re

mpl.use("Agg")


class Visualizer:
    def __init__(self, trf_bed, is_split, lower, upper):
        self.__trf_bed = trf_bed
        self.__is_split = is_split
        self.__lower = lower
        self.__upper = upper
        self.__trf_db = {}
        self.__max_repeat_monomers_db = {"Whole": [0, 0]}
        self.load()

    def load(self):
        # avoid repeat regions generated by sliding window
        region_set = set()
        for _ in self.__trf_bed:
            monomer_len = len(_[6])
            if monomer_len < self.__lower or monomer_len > self.__upper:
                continue
            sid = _[0]
            start_pos = _[1]
            end_pos = _[2]
            if self.__is_split:
                sid, offset, send = sid.split(':::')
                offset = int(offset) - 1
                start_pos += offset
                end_pos += offset
            info = tuple([sid, start_pos, end_pos])
            if info in region_set:
                continue
            region_set.add(info)

            copy_num = _[4]
            if sid not in self.__trf_db:
                self.__trf_db[sid] = {}
            if monomer_len not in self.__trf_db[sid]:
                self.__trf_db[sid][monomer_len] = 0
            self.__trf_db[sid][monomer_len] += copy_num

    def visualize(self, out_pdf, mode='whole'):
        if mode == 'whole':
            whole_trf_db = {}
            for sid in self.__trf_db:
                for monomer_len in self.__trf_db[sid]:
                    if monomer_len not in whole_trf_db:
                        whole_trf_db[monomer_len] = 0
                    whole_trf_db[monomer_len] += self.__trf_db[sid][monomer_len]
            plt.figure(figsize=(10, 10), dpi=100)
            x = [_ for _ in sorted(whole_trf_db)]
            y = [whole_trf_db[_] for _ in sorted(whole_trf_db)]

            for monomer_len, monomer_cnt in zip(x, y):
                if monomer_cnt > self.__max_repeat_monomers_db["Whole"][1]:
                    self.__max_repeat_monomers_db["Whole"][0] = monomer_len
                    self.__max_repeat_monomers_db["Whole"][1] = monomer_cnt

            plt.plot(x, y, color='black', lw=1)
            plt.xticks([_ for _ in range(self.__lower, self.__upper + 1, 50)],
                       [str(_) for _ in range(self.__lower, self.__upper + 1, 50)])
            plt.yticks(rotation=90, va="center")
            plt.xlabel("Repeat monomer length (nt)",
                       fontdict={'size': 20, 'weight': 'bold'},
                       ha='center')
            plt.ylabel("Number of monomer",
                       fontdict={'size': 20, 'weight': 'bold'},
                       va="center", rotation=90, labelpad=20)
            plt.savefig(out_pdf, bbox_inches="tight")
            plt.close('all')
        elif mode == 'single':
            # automatic adjust row and col
            total_cnt = len(self.__trf_db)
            if total_cnt > 100:
                return False

            if total_cnt < 5:
                row = 1
                col = total_cnt
            elif total_cnt < 9:
                row = 2
                col = int(round(total_cnt * 1. / row + .49, 0))
            else:
                col = int(sqrt(total_cnt))
                while not total_cnt % col == 0:
                    col -= 1
                if col <= 2:
                    col = int(sqrt(total_cnt))
                    row = int(round(total_cnt * 1. / col + .49, 0))
                else:
                    row = total_cnt // col

            fig, ax = plt.subplots(nrows=row, ncols=col, figsize=(col * 4, row * 4), dpi=100)
            idx = 0
            for sid in sorted(self.__trf_db, key=lambda x: int(re.findall(r'\d+', x)[0])
                              if len(re.findall(r'\d+', x)) > 0 else 1000):
                x = [_ for _ in sorted(self.__trf_db[sid])]
                y = [self.__trf_db[sid][_] for _ in sorted(self.__trf_db[sid])]

                self.__max_repeat_monomers_db[sid] = [0, 0]
                for monomer_len, monomer_cnt in zip(x, y):
                    if monomer_cnt > self.__max_repeat_monomers_db[sid][1]:
                        self.__max_repeat_monomers_db[sid][0] = monomer_len
                        self.__max_repeat_monomers_db[sid][1] = monomer_cnt

                if row == 1 and col == 1:
                    cur_ax = ax
                elif row == 1:
                    cur_ax = ax[idx]
                else:
                    cur_ax = ax[idx // col][idx % col]
                cur_ax.plot(x, y, color='black', lw=1)
                cur_ax.set_xticks([_ for _ in range(self.__lower, self.__upper + 1, 50)],
                                  [str(_) for _ in range(self.__lower, self.__upper + 1, 50)])
                cur_ax.set_title(sid,
                                 fontdict={'size': 20, 'weight': 'bold'},
                                 pad=20)
                idx += 1

            # delete extra axes
            while idx < row * col:
                fig.delaxes(ax[idx // col][idx % col])
                idx += 1

            fig.text(0.5, 0.01*row, "Repeat monomer length (nt)",
                     fontdict={'size': 20, 'weight': 'bold'}, ha='center')
            fig.text(0.01*col, 0.5, "Number of monomer",
                     fontdict={'size': 20, 'weight': 'bold'}, va='center', rotation=90)
            plt.subplots_adjust(wspace=.25, hspace=.5)
            plt.savefig(out_pdf, bbox_inches='tight')
            plt.close('all')

        return True

    def get_max_monomers_info(self):
        # max_repeat_monomers_db is like: sid => [monomer length, monomer count]
        return self.__max_repeat_monomers_db
