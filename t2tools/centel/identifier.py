class CenTelIdentifier:
    """
    This class is base class for identifying centromeres and telomeres

    Attributes:
        _bed_list:  a 2-dimensions list like below:
                [[seq_name1, 1, 1000, 1000, 50, 1000, ATCG, ATCG...ATCG],
                 ...
                ]
    """

    def __init__(self, bed_list):
        """
        Init attributes

        Args:
            bed_list: simplified bed loaded by io.TRFData
        """
        self._bed_list = bed_list


class CentroIdentifier(CenTelIdentifier):
    """
    This class is a subclass of CentroTeloIdentifier for identifying centromeres
    Attributes:
        __centro_list: a list of centromeres
    """

    def __init__(
        self, bed_list, is_split, lower, upper, minium_copy_number, minium_score
    ):
        """
        Init attributes
        bed_list: simplified bed loaded by io.TRFData
        """
        super().__init__(bed_list)
        self.__centro_list = []
        self.__is_split = is_split
        self.__lower = lower
        self.__upper = upper
        self.__minium_copy_number = minium_copy_number
        self.__minium_score = minium_score

    def identify(self):
        """This function is for identifying centromeres from trf result which loaded by io.TRFData

        Returns:

        """
        length_db = {}
        for sid, _, _, length, _, _, pattern, _ in self._bed_list:
            if self.__is_split:
                sid = sid.split(":::")[0]
            if sid not in length_db:
                length_db[sid] = {}
            pattern_length = len(pattern)
            if pattern_length < self.__lower or pattern_length > self.__upper:
                continue

            if pattern_length not in length_db[sid]:
                length_db[sid][pattern_length] = 0
            length_db[sid][pattern_length] += length

        max_length_db = {}
        max_pattern_db = {}
        for sid in length_db:
            max_length_db[sid] = 0
            max_pattern_db[sid] = ""
            for pattern_length in length_db[sid]:
                if length_db[sid][pattern_length] > max_length_db[sid]:
                    max_length_db[sid] = length_db[sid][pattern_length]
                    max_pattern_db[sid] = pattern_length

        # avoid repeat centro generated by sliding window
        centro_set = set()
        for _ in self._bed_list:
            # each line of _bed_list is like below:
            # sid, start_pos, end_pos, length, copy_num, score, pattern, seq
            pattern_length = len(_[-2])
            copy_num = _[4]
            score = _[5]
            if copy_num < self.__minium_copy_number or score < self.__minium_score:
                continue
            info = [col for col in _]
            if self.__is_split:
                sid, offset, send = info[0].split(":::")
                offset = int(offset) - 1
                info[0] = sid
                info[1] += offset
                info[2] += offset
            else:
                sid = info[0]
            if max_pattern_db[sid] - 1 <= pattern_length <= max_pattern_db[sid] + 1:
                sub_info = tuple(info[:3])
                if sub_info in centro_set:
                    continue
                centro_set.add(sub_info)
                self.__centro_list.append(info)

    def get_centro_list(self):
        """This function return the centromere information identified

        Returns:
            A list of centromere information
        """
        return self.__centro_list

    def get_best_centro_list(self):
        """This function return the best centromere information identified

        Returns:
            A list of centromere information
        """
        merged_centro_list = []
        last_chr = ""
        for _ in sorted(self.__centro_list):
            if not merged_centro_list or _[0] != last_chr:
                merged_centro_list.append([_[0], _[1], _[2], [_]])
            else:
                if _[1] < merged_centro_list[-1][2]:
                    if _[2] > merged_centro_list[-1][2]:
                        merged_centro_list[-1][2] = _[2]
                        merged_centro_list[-1][-1].append(_)
                else:
                    merged_centro_list.append([_[0], _[1], _[2], [_]])
            last_chr = _[0]

        best_candidate_centro_db = {}
        for _ in merged_centro_list:
            if (
                _[0] not in best_candidate_centro_db
                or _[2] - _[1] + 1
                > best_candidate_centro_db[_[0]][2] - best_candidate_centro_db[_[0]][1]
            ):
                best_candidate_centro_db[_[0]] = _

        best_candidate_centro_list = []
        for _ in sorted(best_candidate_centro_db):
            best_candidate_centro_list.append(best_candidate_centro_db[_])
        return best_candidate_centro_list


class TeloIdentifier(CenTelIdentifier):
    """
    This class is a subclass of CentroTeloIdentifier for identifying telomeres
    Attributes:
        __telo_list: a list of telomeres
    """

    def __init__(self, bed_list, seq_length, telo_pattern, rev_telo_pattern, is_split):
        """
        Init attributes
        Args:
            bed_list: simplified bed loaded by io.TRFData
            seq_length: a dictionary of all sequences length
            is_split: if the sequence of fasta is split, position need convert with offset
        """
        super().__init__(bed_list)
        self.__telo_list = []
        self.__seq_length = seq_length
        self.__is_split = is_split
        self.__telo_pattern = telo_pattern
        self.__rev_telo_pattern = rev_telo_pattern

    def identify(self):
        """This function is for identifying telomeres from trf result which loaded by io.TRFData

        Returns:

        """
        if self.__is_split:
            length_db = {}
            for id in self.__seq_length:
                sid = id.split(":::")[0]
                if sid not in length_db:
                    length_db[sid] = 0
                length_db[sid] += self.__seq_length[id]
            self.__seq_length = length_db

        # avoid repeat telo generated by sliding window
        telo_set = set()
        for _ in self._bed_list:
            # each line of _bed_list is like below:
            # sid, start_pos, end_pos, length, copy_num, score, pattern, seq
            sid = _[0]
            start_pos = _[1]
            end_pos = _[2]
            if self.__telo_pattern in _[-1] or self.__rev_telo_pattern in _[-1]:
                if self.__is_split:
                    sid, offset, send = sid.split(":::")
                    offset = int(offset) - 1
                    start_pos += offset
                    end_pos += offset

                if start_pos < self.__seq_length[sid] / 2.0:
                    pos_marker = "start"
                elif end_pos > self.__seq_length[sid] / 2.0:
                    pos_marker = "end"
                else:
                    pos_marker = "undetermined"
                info = tuple([sid, start_pos, end_pos])
                if info in telo_set:
                    continue
                telo_set.add(info)
                self.__telo_list.append(
                    [sid, start_pos, end_pos, _[3], _[-2], pos_marker, _[4]]
                )

    def get_telo_list(self):
        """This function return the telomere information identified

        Returns:
            A list of telomere information
        """
        return self.__telo_list

    def get_best_telo_list(self):
        """This function return the best telomere information identified

        Returns:
            A list of telomere information
        """
        best_candidate_telo_db = {}
        for _ in sorted(self.__telo_list):
            sid = _[0]
            sp = _[1]
            ep = _[2]
            if sid not in best_candidate_telo_db:
                best_candidate_telo_db[sid] = [_, _]
            if sp < best_candidate_telo_db[sid][0][1]:
                best_candidate_telo_db[sid][0] = _
            if ep > best_candidate_telo_db[sid][1][2]:
                best_candidate_telo_db[sid][1] = _

        best_telo_list = []
        for _ in sorted(best_candidate_telo_db):
            if best_candidate_telo_db[_][0] == best_candidate_telo_db[_][1]:
                best_telo_list.append(best_candidate_telo_db[_][0])
            else:
                best_telo_list.extend(best_candidate_telo_db[_])
        return best_telo_list
